<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>KML Debug Test</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
  body { margin: 0; background: #111; color: white; font-family: monospace; }
  #map { width: 100vw; height: 70vh; }
  #log { padding: 10px; font-size: 12px; background: #1a1a2e; height: 30vh; overflow: auto; }
  .ok { color: #00ff64; } .err { color: #ff3d3d; } .info { color: #00e5ff; }
</style>
</head>
<body>
<div id="map"></div>
<div id="log"><p class="info">Loading KML test...</p></div>

<script>
const log = (msg, cls='info') => {
  const p = document.createElement('p');
  p.className = cls;
  p.textContent = msg;
  document.getElementById('log').prepend(p);
};

const map = L.map('map').setView([13.0827, 80.2707], 11);
L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png').addTo(map);

fetch('/0f0ccbda-9485-4964-b3b1-6ce53af82bbb.kml')
  .then(r => {
    log(`Fetch status: ${r.status} ${r.ok ? 'OK' : 'FAILED'}`, r.ok ? 'ok' : 'err');
    if (!r.ok) throw new Error('HTTP ' + r.status);
    return r.text();
  })
  .then(kmlText => {
    log(`KML size: ${kmlText.length} bytes`, 'ok');
    
    // Parse KML manually
    const parser = new DOMParser();
    const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
    const placemarks = kmlDoc.querySelectorAll('Placemark');
    log(`Placemarks found: ${placemarks.length}`, placemarks.length > 0 ? 'ok' : 'err');

    // Extract polygons directly without togeojson
    const allLatLngs = [];
    let rendered = 0;
    
    placemarks.forEach(pm => {
      const name = pm.querySelector('name')?.textContent || 'Unknown';
      const coordEls = pm.querySelectorAll('coordinates');
      
      coordEls.forEach(coordEl => {
        const raw = coordEl.textContent.trim();
        const points = raw.split(/\s+/).filter(s => s.includes(','));
        const latlngs = points.map(p => {
          const parts = p.split(',');
          return [parseFloat(parts[1]), parseFloat(parts[0])]; // lat,lng
        }).filter(ll => !isNaN(ll[0]) && !isNaN(ll[1]));
        
        if (latlngs.length > 2) {
          L.polygon(latlngs, {
            color: '#00E5FF',
            weight: 1.5,
            fill: true,
            fillColor: '#00E5FF',
            fillOpacity: 0.06,
            opacity: 0.85
          }).bindTooltip(`<b>${name}</b>`).addTo(map);
          rendered++;
          allLatLngs.push(...latlngs);
        }
      });
    });

    log(`Polygons rendered: ${rendered}`, rendered > 0 ? 'ok' : 'err');
    
    if (allLatLngs.length > 0) {
      map.fitBounds(L.latLngBounds(allLatLngs), {padding:[40,40]});
      log('Map fitted to bounds', 'ok');
    }
  })
  .catch(err => {
    log(`ERROR: ${err.message}`, 'err');
  });
</script>
</body>
</html>
